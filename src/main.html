<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Missile game</title>
  <script src="gown/docs/lib/pixi/pixi.js"></script>
  <script src="tink.js"></script>
  <script src="gown/docs/dist/gown.js"></script>
</head>

<body>
  <script>
    //Set up Pixi and load the texture atlas files - call the `setup`
    //function when they've loaded
    let app = new PIXI.Application(400, 600, {backgroundColor : 0x3FA000});
    document.body.appendChild(app.view);
    let tink = new Tink(PIXI, app.view);
    //Alias name
    let Loader = PIXI.loader;
    let Sprite = PIXI.Sprite;
    let Texture = PIXI.Texture;
    let TilingSprite = PIXI.extras.TilingSprite;
    let TextureCache = PIXI.utils.TextureCache;
    let Rectangle = PIXI.Rectangle;
    let Text = PIXI.Text;
    let Container = PIXI.Container;
    let Graphics = PIXI.Graphics;
    let AnimatedSprite = PIXI.extras.AnimatedSprite;
    //Game variable
    let state;
    let pointer;
    let background;
    let enemies = new Container();
    let timeWaitSpawnEnemy = 120; //About 1/60s so 120 = 2s
    let addPosision = 2;
    let scaleTimes = 2;
    let timeWaitTap = 15;
    let countTap = 0;
    let coin = 10;
    let enemyMaxHealth = 5;
    let coinPerEnemy = 10;
    let textHandler;
    let spawnHandler;
    let text = new Text("Tap to start!", {fontSize: 50, align: "center"});
    let alertText = new Text("Not enough coin to unlock!", {fontSize: 20, fill: "red", align: "center"});
    let coinText = new Text("", {fontSize: 30});
    let message;
    let explosionTexture;
    let group, scroll_group;
    let rectangle = new Graphics();
    let scrollWidth = app.view.width;
    let scrollHeight = 100;
    let isLoading = true;
    let currentMissile;
    let explosionTextures;
    let missile = {
      mId: 0,
      damage: 1,
      kind: "bam",
      isLocked: false,
      coinNeededToUnlock: 0,
      coinPerShoot: 1,
      missileText: null,
      renderSprite: function(parent, missile) {
        let mContainer = new Container();
        let m = new Sprite(
          frame("../images/tankes.png", 128, 64, 32, 32)
        );
        let locker = new Sprite(
          frame("../images/tankes.png", 224, 64, 32, 32)
        );
        let coinPerShootText = new Text(missile.coinPerShoot + "C", {fontSize: 20, align: "center"});
        let damageText = new Text(missile.damage + "P", {fontSize: 20, align: "center"});

        missile.missileText = new Text("Need: " + missile.coinNeededToUnlock + "C", {fontSize: 20, fill: "white", align: "center"});
        coinPerShootText.visible = false;
        damageText.visible = false;
        if (!missile.isLocked) {
          locker.visible = false;

        }
        if (currentMissile.mId === missile.mId) {
          missile.missileText.visible = true;
          coinPerShootText.visible = true;
          damageText.visible = true;
          missile.missileText.text = "Selected";
        }
        m.interactive = true;
        missile.missileText.x = m.x;
        missile.missileText.y = scroll_group.height - missile.missileText.height;
        m.height = scroll_group.height - missile.missileText.height;
        m.width = 100;
        coinPerShootText.x = m.width - coinPerShootText.width;
        damageText.x = m.width - damageText.width;
        damageText.y = coinPerShootText.y + coinPerShootText.height;

        m.on("click", function(e){
          if (currentMissile.damage === missile.damage) return;
          if (missile.isLocked) {
            if (missile.coinNeededToUnlock < coin) {
              coin -= missile.coinNeededToUnlock;
              missile.isLocked = false;
              locker.visible = false;
              coinPerShootText.visible = true;
              damageText.visible = true;
              missile.missileText.visible = false;
            } else {
              showAlert("Not enough coin to unlock!");
            }
          } else {
            currentMissile.missileText.visible = false;
            currentMissile = missile;
            currentMissile.missileText.visible = true;
            currentMissile.missileText.text = "Selected";
          }
        });
        mContainer.addChild(m);
        mContainer.addChild(locker);
        mContainer.addChild(coinPerShootText);
        mContainer.addChild(damageText);
        mContainer.addChild(missile.missileText);

        parent.addChild(mContainer);
      }
    };
    //Load texture
    Loader
            .add("../images/bg.jpg")
            .add("../images/monster.png")
            .add("../images/tankes.png")
            .add("../images/explosion1.png")
            .add("../images/explosion2.png")
            .add("../images/explosion3.png")
            .add("../images/missile.png")
            .load(setup);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Declare any variables used in more than one function
    function setup() {
      //Initialize the game sprites, set the game `state` to `play`
      //and start the 'gameLoop'
      // Create and Set bg
      background = new TilingSprite(Loader.resources["../images/bg.jpg"].texture, app.view.width, app.view.height);
      app.stage.addChild(background);
      background.x = 0;
      background.y = 0;
      //Create explosion animation
      explosionTextures = [
        Loader.resources["../images/explosion1.png"].texture,
        Loader.resources["../images/explosion2.png"].texture,
        Loader.resources["../images/explosion3.png"].texture,
      ];
      //Add enemies
      app.stage.addChild(enemies);
      //Set text
      text.x = app.view.width / 2 - text.width / 2;
      text.y = app.view.height / 2 - text.height / 2;
      coinText.x = 5;
      coinText.y = 0;
      alertText.x = app.view.width / 2 - alertText.width / 2;
      alertText.y = 30;
      coinText.text = "Coin: " + coin;
      app.stage.addChild(text);
      app.stage.addChild(coinText);
      app.stage.addChild(alertText);
      //Spawn enemy
      //Set pointer
      pointer = tink.makePointer();
      //set the game state to `play`
      state = main;
      text.visible = true;
      textEffect(text, 30);
      alertText.visible = false;
      explosionTexture = frame("../images/tankes.png", 96, 64 ,32, 32);
      //Setup scroll
      rectangle.beginFill(0x000000);
      rectangle.lineStyle(4, 0x000000, 1);
      rectangle.drawRect(0, 0, scrollWidth - 4, scrollHeight);
      rectangle.x = 2;
      rectangle.y = app.view.height - 100;
      rectangle.interactive = true;
      rectangle.endFill();
      rectangle.visible = false;
      app.stage.addChild(rectangle);
      //Load theme gown
      var theme = new GOWN.ThemeParser("gown/docs/themes/assets/aeon_desktop/aeon_desktop.json");
      theme.once(GOWN.Theme.COMPLETE, onComplete, this);
      GOWN.loader.load();
      //Current missile = default missile
      //Start the game loop
      gameLoop();
    }

    function gameLoop() {
      //Runs the current game `state` in a loop and render the sprites
      requestAnimationFrame(gameLoop);
      tink.update();
      state();
    }

    function main() {
      coinText.visible = false;
      if (!isLoading) {
        text.text = "Tap to start!";
        pointer.tap = () => {
            rectangle.visible = true;
            app.ticker.remove(textHandler);
            text.visible = false;
            coinText.visible = true;
            spawnEnemies(timeWaitSpawnEnemy);
            scroll_group.visible = true;
            state = play;
            pointer.tap = null;
        }
      } else text.text = "Loading...";
    }
    function play() {
      //All the game logic goes here
      background.tilePosition.y += addPosision;
      //Move all enemy in enemies forward with bg
      enemies.children.some(enemy => {
        enemy.y += addPosision; //Add equal to background so it's move along with bg
        //Destroy enemy when out of screen
        if (enemy.y > app.view.height - scrollHeight) {
          enemies.removeChild(enemy);
        }
      });
      coinText.text = "Coin: " + coin;
      if (coin === 0) {
        state = end;
      }
      //Spawn Enemy
    }

    function end() {
      text.visible = true;
      text.text = "Game Over!!"
      //All the code that should run at the end of the game goes here
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Game func
    //Complete load gown theme and gen UI
    function onComplete() {
      group = new GOWN.LayoutGroup();
      group.layout = new GOWN.layout.HorizontalLayout();
      scroll_group = new GOWN.ScrollContainer();
      scroll_group.x = 10;
      scroll_group.y = app.view.height - 95;
      scroll_group._useMask = false;
      scroll_group.height = scrollHeight - 10;
      scroll_group.width = scrollWidth - 20;
      // create layout container and add some buttons
      for (var i = 0; i < 10; i++) {
          let m = Object.create(missile);
          m.mId = i + 1;
          if (i !== 0) {
            m.kind = "bam" + i;
            m.damage = i + 1;
            m.isLocked = true;
            m.coinNeededToUnlock = i * 10;
            m.coinPerShoot = i * 2;
          } else {
            m.damage = 10;
            currentMissile = m;
          }
          m.renderSprite(group, m);
          if (i < 10 - 1)
            group.addSpacer(10);
      }
      scroll_group.viewPort = group;
      scroll_group.visible = false;
      app.stage.addChild(scroll_group);
      isLoading = false;
    }

    function createEnemies() {
      let enemy = new Sprite(
        frame("../images/tankes.png", 32, 0 ,32, 32)
      );
      //Set death animation
      let explosionAnimation = new AnimatedSprite(explosionTextures);
      explosionAnimation.animationSpeed = 0.2
      explosionAnimation.width = 128;
      explosionAnimation.height = 128;
      explosionAnimation.loop = false;
      explosionAnimation.visible = false;
      explosionAnimation.pivot.x = 0.5;
      explosionAnimation.pivot.y = 0.5;

      //Set random position in horizon
      enemy.x = Math.floor((Math.random()*336));
      enemy.y = -64;
      //Set scale enemy (will hange later)
      enemy.scale.x = scaleTimes;
      enemy.scale.y = scaleTimes;
      enemy.score = coinPerEnemy;
      enemy.health = enemyMaxHealth;
      enemy.healthText = new Text("Health: " + enemy.health, {fontSize: 20, fill: "red", align: "center"});
      enemy.healthText.x = enemy.x - enemy.healthText.width / 2 + enemy.width / 2;
      enemy.healthText.y = enemy.y - enemy.healthText.height;
      //Circle collider
      // enemy.circular = true;
      enemy.interactive = true;
      enemy.countTap = 0;
      let timer = 0;
      let isClicked = false;
      // enemy.on("tap", function(e){ // Mobile test
      enemy.on("click", function(e){
        //handle double click enemy
        if (!isClicked) {
          app.ticker.add(tapHandler = function(delta) {
            timer += delta;
          });
          isClicked = true;
        }
        enemy.countTap++;
        if (enemy.countTap === 2 && timer < timeWaitTap) {
          enemy.interactive = false;
          //Stop scroll
          if (coin >= currentMissile.coinPerShoot) {
            coin -= currentMissile.coinPerShoot;
            text.text = "Fire!!!!"
            text.visible = true;
            state = pause;
            wait(500).then(() => {
              text.visible = false;
              if (enemy.texture != explosionTexture) {
                enemy.health -= currentMissile.damage;
                //Enemy death
                if (enemy.health <= 0 ) {
                  enemy.removeAllListeners();
                  coin += enemy.score;
                  enemies.removeChild(enemy);
                  explosionAnimation.position.set(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2);
                  enemies.addChild(explosionAnimation);
                  explosionAnimation.visible = true;
                  explosionAnimation.play();
                  enemy.health = 0;
                  enemy.healthText.visible = false;
                }
              }
              enemy.healthText.text = "Health: " + enemy.health;
              app.ticker.speed = 1;
              enemy.interactive = true;
              state = play;
            });
            isClicked = false;
            timer = 0;
            app.ticker.remove(tapHandler);
            enemy.countTap = 0;
          } else {
            showAlert("Not enough coin to fire!");
          }
        }
        if (timer >= timeWaitTap) {
          isClicked = false;
          timer = 0;
          app.ticker.remove(tapHandler);
          enemy.countTap = 0;
        }
      })
      enemies.addChild(enemy);
      enemies.addChild(enemy.healthText);
    }

    function pause() {
        app.ticker.speed = 0;
    }
    //Execute a function in a short of time and loop with update
    function spawnEnemies(time) {
      let countTime = time;
      app.ticker.add(spawnHandler = function(delta) {
        //Countdown time to spawn
        if (countTime < 0) {
          createEnemies();
          countTime = time;
        } else {
          //delta is time value from last frame to this frame
          countTime -= delta;
        }
      });
    }
    //Start text effect
    function textEffect(text, time) {
      let countTime = time;
      app.ticker.add(textHandler = function(delta) {
        //Countdown time to spawn
        if (countTime < 0) {
          text.visible = false;
          wait(250).then(() => countTime = time);
        } else {
          //delta is time value from last frame to this frame
          countTime -= delta;
          text.visible = true;
        }
      });
    }
    //Show alert
    function showAlert(mess) {
      alertText.visible = true;
      alertText.text = mess;
      wait(2000).then(() => {
        alertText.visible = false;
      });
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Helper func
    function frame(source, x, y, width, height) {
      let texture, imageFrame;
      //If the source is a string, it's either a texture in the
      //cache or an image file
      if (typeof source === "string") {
        if (TextureCache[source]) {
          texture = new Texture(TextureCache[source]);
        }
      } //If the `source` is a texture, use it
      else if (source instanceof Texture) {
        texture = new Texture(source);
      }
      if(!texture) {
        console.log(`Please load the ${source} texture into the cache.`);
      } else {
      //Make a rectangle the size of the sub-image
        imageFrame = new Rectangle(x, y, width, height);
        texture.frame = imageFrame;
        return texture;
      }
    }

    function wait(duration = 0) {
      return new Promise((resolve, reject) => {
      setTimeout(resolve, duration);
      });
    }

    function linkFont(source) {
       //Use the font's filename as the `fontFamily` name. This code captures
       //the font file's name without the extension or file path
       let fontFamily = source.split("/").pop().split(".")[0];
       //Append an `@afont-face` style rule to the head of the HTML document
       let newStyle = document.createElement("style");
       let fontFace
       = "@font-face {font-family: '" + fontFamily
       + "'; src: url('" + source + "');}";
       newStyle.appendChild(document.createTextNode(fontFace));
       document.head.appendChild(newStyle);
    }

    function contain(sprite, container) {
      //Create a `Set` called `collision` to keep track of the
      //boundaries with which the sprite is colliding
      var collision = new Set();
      //Left
      //If the sprite's x position is less than the container's x position,
      //move it back inside the container and add "left" to the collision Set
      if (sprite.x < container.x) {
        sprite.x = container.x;
        collision.add("left");
      }
      //Top
      if (sprite.y < container.y) {
        sprite.y = container.y;
        collision.add("top");
      }
      //Right
      if (sprite.x + sprite.width > container.width) {
        sprite.x = container.width - sprite.width;
        collision.add("right");
        }
      //Bottom
      if (sprite.y + sprite.height > container.height) {
        sprite.y = container.height - sprite.height;
        collision.add("bottom");
      }
      //If there were no collisions, set `collision` to `undefined`
      if (collision.size === 0) collision = undefined;
      //Return the `collision` value
      return collision;
    }

  </script>
</body>
</html>
